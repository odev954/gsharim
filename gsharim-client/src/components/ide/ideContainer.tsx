import { useState, useCallback, useMemo, useEffect } from "react";
import usePython from "hooks/python";
import { once, trigger } from "utils/customEvents";
import { useLogger } from "hooks/logger";
import { PythonError, OutputLine, OutputLineType, IdeProps } from "./types";
import IdeComponent from "./ideComponent";
import {
	InputEventName,
	CancelEventName,
	DefaultMaxOutputSize,
	InitialOutputState,
	DefaultApi,
} from "./consts";
import { createEffectiveApi, generateOutputLine } from "./utils";
import { usePythonTest } from "./hooks";

export default function IdeContainer({
	api = DefaultApi,
	autoAwait = true,
	defaultCode = "",
	editable = true,
	maxOutputSize = DefaultMaxOutputSize,
	verboseDelay,
	pythonPrefix,
	pythonSuffix,
	autoRun,
	hideRunningButtons,
	pythonTest,
	testBeforeSuffix = true,
	onTestRun,
}: IdeProps): JSX.Element {
	const [code, setCode] = useState(defaultCode);
	const [output, setOutput] = useState<OutputLine[]>(InitialOutputState);
	const [error, setError] = useState<PythonError | undefined>();
	const [isAcceptingInput, setIsAcceptingInput] = useState(false);
	const logger = useLogger();
	useEffect(() => {
		if (!pythonTest) {
			onTestRun?.(true);
		}
	}, [pythonTest, onTestRun]);

	const pushOutputLine = useCallback(
		(text: string, lineType: OutputLineType) => {
			setOutput((current) => {
				const newOutputElement = generateOutputLine(text, lineType);
				const newOutput = current.concat([newOutputElement]);

				return newOutput.slice(-maxOutputSize);
			});
		},
		[maxOutputSize]
	);

	const appendOutput = useCallback(
		(newLine: string) => {
			pushOutputLine(newLine, "output");
		},
		[pushOutputLine]
	);

	// the communication with the hook use Python is done in messages.
	// when an event happens in python it is passed to the ide using a message
	// the message can be an output or an error
	const onPythonMessage = useCallback(
		(newOutput: string, errorFlag: boolean) => {
			if (errorFlag) {
				const parsedErrors = JSON.parse(newOutput) as PythonError;
				setError(parsedErrors);

				const newOutputElement = generateOutputLine(parsedErrors.msg, "error");
				setOutput([newOutputElement]);
			} else {
				appendOutput(newOutput);
				setError(undefined);
			}
		},
		[appendOutput]
	);

	// the input command in python is overwritten with an api function
	const onInputSubmit = useCallback((value: string) => {
		trigger(InputEventName, value);
	}, []);

	// this is the input function that will be passed to the hook usePython as the new inputFunction
	// the reason the communication works using events, is that if it would work using states, then the api function will
	// change when the state changes, and that will cause rerender - and the webworker will be restarted
	const input = useCallback(async () => {
		setIsAcceptingInput(true);
		const returnValuePromise = new Promise<string | null>((res) => {
			once(InputEventName, (event: CustomEvent) => {
				const inputText = event.detail;
				res(inputText);
			});
			once(CancelEventName, () => {
				res(null);
			});
		});
		const returnValue = await returnValuePromise;
		if (returnValue === null) {
			return "";
		}
		pushOutputLine(returnValue, "input");
		setIsAcceptingInput(false);
		return returnValue;
	}, [pushOutputLine]);

	// this hook handles the logic that is necessary to handle the python test
	// the way the test is implemented, the test is added to the suffix with some additional code
	const { setTestPassedApiFunction, runCodeRunWithPythonTest } = usePythonTest(
		testBeforeSuffix,
		onTestRun,
		pythonSuffix,
		pythonTest
	);

	// the api that usePython will use, containing the function that will approve that the test has passed, and the new input function
	const effectiveApi = useMemo(() => {
		return createEffectiveApi(api, input, setTestPassedApiFunction);
	}, [api, input, setTestPassedApiFunction]);

	const {
		runPython,
		restartPythonInterpreter,
		isRunning,
		isReady,
		currentLine,
	} = usePython({
		handlePythonOutput: onPythonMessage,
		api: effectiveApi,
		autoAwait,
		verboseDelay,
	});

	// handling the change in the code of the ide
	const handleChange = useCallback((value: string | undefined) => {
		setCode(value || "");
	}, []);

	// this function handles the logic for running the python code given a suffix.
	// the suffix will be created in the usePythonTest hook, and will contain the given suffix and additional code needed for the test
	const runPythonCodeFromSuffix = useCallback(
		(suffix?: string) => {
			setOutput(InitialOutputState);
			runPython(code, pythonPrefix, suffix);
			logger.info("code-running", "user is running code", { code });
		},
		[runPython, code, pythonPrefix, logger]
	);

	// run the code stored in the state: code
	// if there the suffix is generated by the function runCodeRunWithPythonTest and passed to runPythonCodeFromSuffix
	const runPythonCode = useCallback(() => {
		runCodeRunWithPythonTest(runPythonCodeFromSuffix);
	}, [runPythonCodeFromSuffix, runCodeRunWithPythonTest]);

	// the python code is running on a webworker that is managed in the hook: usePython
	const restartWebWorker = useCallback(() => {
		setOutput(InitialOutputState);
		setIsAcceptingInput(false);
		// we must send a cancel event, otherwise there will be 2 input promises open and will cause the input to be printed twice
		trigger(CancelEventName, null);
		restartPythonInterpreter();
	}, [restartPythonInterpreter]);

	useEffect(() => {
		if (isReady && autoRun) {
			runPythonCode();
		}
	}, [autoRun, runPythonCode, isReady]);

	return (
		<IdeComponent
			handleChange={handleChange}
			onRun={runPythonCode}
			onStop={restartWebWorker}
			outputText={output}
			error={error}
			isRunning={isRunning}
			isReady={isReady}
			defaultCode={defaultCode}
			onInputSubmit={onInputSubmit}
			api={api}
			isAcceptingInput={isAcceptingInput}
			editable={editable && !isRunning}
			currentLine={currentLine}
			autoRunMode={autoRun}
			hideRunningButtons={hideRunningButtons}
		/>
	);
}
